/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 zombie.glb --transform 
Files: zombie.glb [238.62KB] > D:\Daniel\Programming projects\React Three Fiber - Scary Challange Game\r3f-rapier-scarycg\public\models\zombie-transformed.glb [43.43KB] (82%)
*/

/*
auto-generated by: https://github.com/pmdrs/gltfjsx
author: Quaternius (https://quaternius.com/)
license: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)
source: https://quaternius.com/packs/cubeworldkit.html
title: Zombie
*/

import { useEffect, useMemo, useRef } from "react";
import { useFrame, useGraph, useThree } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import { useGameStore } from "../stores/gameStore";

function Zombie({ id, initialHealth = 100, props }) {
  const group = useRef();
  const headRef = useRef();

  //State and Store
  const [health, setHealth] = useState(initialHealth);
  const { damageEnemy, removeEnemy } = useGameStore();

  const { scene, animations } = useGLTF("./models/zombie-transformed.glb");
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions } = useAnimations(animations, group);
  const camera = useThree();

  useEffect(() => {
    const headMesh = group.current?.children[0]?.children[2]?.children[0];
    if (headMesh) {
      headRef.current = headMesh;
    }
  }, []);

  useEffect(() => {
    if (!actions) return;

    const WalkAction =
      actions["EnemyArmature|EnemyArmature|EnemyArmature|Walk"];
    if (WalkAction) {
      WalkAction.play();
      //WalkAction.timeScale = 20;
    }
    const attackAction =
      actions["EnemyArmature|EnemyArmature|EnemyArmature|Attack"];
    if (attackAction) {
      attackAction.play();
      attackAction.timeScale = 0.11;
    }
  }, [actions]);

  useFrame(() => {
    if (headRef.current && camera) {
      const directionToCamera = camera.position
        .clone()
        .sub(headRef.current.position);

      headRef.current.lookAt(camera.position);

      // Begränsa rotationen om det behövs
      const currentRotation = headRef.current.rotation.clone();
      currentRotation.x = Math.max(-0.5, Math.min(0.5, currentRotation.x)); // Begränsa upp/ner
      currentRotation.y = Math.max(-1, Math.min(1, currentRotation.y)); // Begränsa vänster/höger

      headRef.current.rotation.copy(currentRotation);
    }
  });

  const handleDamage = (amount) => {
    const currentHealth = health - amount;
    setHealth(currentHealth);

    if (currentHealth <= 0) {
      const deathAction =
        actions["EnemyArmature|EnemyArmature|EnemyArmature|Death"];
      if (deathAction) {
        Object.values(actions).forEach((action) => action.stop());
        deathAction.play();

        setTimeout(() => removeEnemy(id), deathAction.duration * 1000);
      } else {
        removeEnemy(id);
      }
    }
  };

  return (
    <group
      ref={group}
      userData={{ type: "enemy", health, handleDamage, id }}
      {...props}
      dispose={null}
    >
      <group name="Root_Scene">
        <primitive object={nodes.Root} />
        <skinnedMesh
          name="Cube000"
          geometry={nodes.Cube000.geometry}
          material={materials.Atlas}
          skeleton={nodes.Cube000.skeleton}
          castShadow
        />

        {/* {console.log(Zombie())} */}
      </group>
    </group>
  );
}

useGLTF.preload("./models/zombie-transformed.glb");

export default Zombie;

//headMesh = scene.children[0].children[2].children[0];
